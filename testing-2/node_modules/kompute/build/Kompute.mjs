(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.Kompute = global.Kompute || {})));
}(this, (function (exports) { 'use strict';

var Vector3D = function Vector3D(x, y, z) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
};

Vector3D.prototype.set = function (x, y, z) {
  this.x = x;
  this.y = y;
  this.z = z;
  return this;
};

Vector3D.prototype.copy = function (vect) {
  return this.set(vect.x, vect.y, vect.z);
};

Vector3D.prototype.clone = function () {
  return new Vector3D().copy(this);
};

Vector3D.prototype.multiplyScalar = function (scalar) {
  this.set(this.x * scalar, this.y * scalar, this.z * scalar);
  return this;
};

Vector3D.prototype.min = function (vect) {
  this.x = Math.min(this.x, vect.x);
  this.y = Math.min(this.y, vect.y);
  this.z = Math.min(this.z, vect.z);

  return this;
};

Vector3D.prototype.max = function (vect) {
  this.x = Math.max(this.x, vect.x);
  this.y = Math.max(this.y, vect.y);
  this.z = Math.max(this.z, vect.z);

  return this;
};

Vector3D.prototype.getLength = function () {
  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
};

Vector3D.prototype.add = function (vect) {
  this.x += vect.x;
  this.y += vect.y;
  this.z += vect.z;

  return this;
};

Vector3D.prototype.sub = function (vect) {
  this.x -= vect.x;
  this.y -= vect.y;
  this.z -= vect.z;

  return this;
};

Vector3D.prototype.normalize = function () {
  var len = this.getLength();
  if (len == 0) {
    return this;
  }
  this.x = this.x / len;
  this.y = this.y / len;
  this.z = this.z / len;

  return this;
};

Vector3D.prototype.dot = function (vect) {
  return this.x * vect.x + this.y * vect.y + this.z * vect.z;
};

Vector3D.prototype.applyQuaternion = function (quaternion) {
  var x = this.x,
      y = this.y,
      z = this.z;
  var qx = quaternion.x,
      qy = quaternion.y,
      qz = quaternion.z,
      qw = quaternion.w;
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;
  this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return this;
};

Vector3D.prototype.cross = function (vec) {
  return this.set(this.y * vec.z - this.z * vec.y, this.z * vec.x - this.x * vec.z, this.x * vec.y - this.y * vec.x);
};

Vector3D.prototype.negate = function () {
  return this.set(-this.x, -this.y, -this.z);
};

Vector3D.prototype.eql = function (vec) {
  return vec.x == this.x && vec.y == this.y && vec.z == this.z;
};

Vector3D.prototype.toFixed = function (num) {
  return this.set(this.x.toFixed(num), this.y.toFixed(num), this.z.toFixed(num));
};

Vector3D.prototype.getDistanceSq = function (vec) {
  var xDiff = this.x - vec.x;
  var yDiff = this.y - vec.y;
  var zDiff = this.z - vec.z;

  return xDiff * xDiff + yDiff * yDiff + zDiff * zDiff;
};

var VectorPool = function VectorPool(size) {
  this.index = 0;

  this.vectors = [];
  for (var i = 0; i < size; i++) {
    this.vectors.push(new Vector3D());
  }
};

VectorPool.prototype.get = function () {
  var vect = this.vectors[this.index++];
  if (this.index == this.vectors.length) {
    this.index = 0;
  }
  return vect;
};

var vectorPool = new VectorPool(10);

var MathUtils = function MathUtils() {};

MathUtils.prototype.clamp = function (val, min, max) {
  return Math.max(min, Math.min(max, val));
};

MathUtils.prototype.uuidv4 = function () {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
};

var vectorPool$1 = new VectorPool(10);

var Box = function Box(centerPosition, size) {
  this.min = new Vector3D();
  this.max = new Vector3D();

  this.setFromCenterAndSize(centerPosition, size);
};

Box.prototype.setFromCenterAndSize = function (center, size) {
  var half = vectorPool$1.get().copy(size).multiplyScalar(0.5);
  this.min.set(center.x - half.x, center.y - half.y, center.z - half.z);
  this.max.set(center.x + half.x, center.y + half.y, center.z + half.z);
  return this;
};

Box.prototype.makeEmpty = function () {
  this.min.set(Infinity, Infinity, Infinity);
  this.max.set(-Infinity, -Infinity, -Infinity);
  return this;
};

Box.prototype.expandByPoint = function (point) {
  this.min.min(point);
  this.max.max(point);

  return this;
};

Box.prototype.intersectsBox = function (box) {
  return !(box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z);
};

Box.prototype.containsBox = function (box) {
  return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
};

Box.prototype.setFromTwoVectors = function (vec1, vec2, thickness) {
  this.makeEmpty();
  this.expandByPoint(vec1);
  this.expandByPoint(vec2);
  var v = vectorPool$1.get().copy(vec1);
  v.x = vec1.x + thickness;
  this.expandByPoint(v);
  v.x = vec1.x - thickness;
  this.expandByPoint(v);
  v.x = vec1.x;
  v.y = vec1.y + thickness;
  this.expandByPoint(v);
  v.y = vec1.y - thickness;
  this.expandByPoint(v);
  v.y = vec1.y;
  v.z = vec1.z + thickness;
  this.expandByPoint(v);
  v.z = vec1.z - thickness;
  this.expandByPoint(v);

  v.copy(vec2);
  v.x = vec2.x + thickness;
  this.expandByPoint(v);
  v.x = vec2.x - thickness;
  this.expandByPoint(v);
  v.x = vec2.x;
  v.y = vec2.y + thickness;
  this.expandByPoint(v);
  v.y = vec2.y - thickness;
  this.expandByPoint(v);
  v.y = vec2.y;
  v.z = vec2.z + thickness;
  this.expandByPoint(v);
  v.z = vec2.z - thickness;
  this.expandByPoint(v);

  return this;
};

Box.prototype.isEmpty = function () {
  return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
};

Box.prototype.getBoundingRadius = function () {
  var v = vectorPool$1.get().set(0, 0, 0);

  if (!this.isEmpty()) {
    v.copy(this.max).sub(this.min);
  }

  return v.getLength() * 0.5;
};

var Nearby = function Nearby(width, height, depth, binSize) {
  this.limitBox = this.createBox(0, 0, 0, width, height, depth);
  this.binSize = binSize;

  this.bin = new Map();

  this.reusableResultMap = new Map();
};

Nearby.prototype.createBox = function (x, y, z, width, height, depth) {
  var bb = {};

  bb.containsBox = function (box) {
    return this.minX <= box.minX && box.maxX <= this.maxX && this.minY <= box.minY && box.maxY <= this.maxY && this.minZ <= box.minZ && box.maxZ <= this.maxZ;
  };

  bb.setFromCenterAndSize = function (x, y, z, width, height, depth) {
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var halfDepth = depth / 2;

    this.minX = x - halfWidth;
    this.maxX = x + halfWidth;
    this.minY = y - halfHeight;
    this.maxY = y + halfHeight;
    this.minZ = z - halfDepth;
    this.maxZ = z + halfDepth;
  };

  bb.setFromCenterAndSize(x, y, z, width, height, depth);

  return bb;
};

Nearby.prototype.createObject = function (id, box) {
  var self = this;

  var obj = {
    id: id,
    box: box,
    binInfo: new Map()
  };

  return obj;
};

Nearby.prototype.insert = function (obj) {
  if (!this.limitBox.containsBox(obj.box)) {
    return;
  }

  var BIN_SIZE = this.binSize;

  var box = obj.box;
  var minX = box.minX;
  var minY = box.minY;
  var minZ = box.minZ;
  var maxX = box.maxX;
  var maxY = box.maxY;
  var maxZ = box.maxZ;

  var round = Math.round(minX / BIN_SIZE) * BIN_SIZE;
  var minXLower, minXUpper;
  if (round <= minX) {
    minXLower = round;
    minXUpper = minXLower + BIN_SIZE;
  } else {
    minXUpper = round;
    minXLower = round - BIN_SIZE;
  }

  round = Math.round(maxX / BIN_SIZE) * BIN_SIZE;
  var maxXLower, maxXUpper;
  if (round < maxX) {
    maxXLower = round;
    maxXUpper = maxXLower + BIN_SIZE;
  } else {
    maxXUpper = round;
    maxXLower = round - BIN_SIZE;
  }
  if (minXLower > maxXLower) {
    maxXLower = minXLower;
  }

  round = Math.round(minY / BIN_SIZE) * BIN_SIZE;
  var minYLower, minYUpper;
  if (round <= minY) {
    minYLower = round;
    minYUpper = minYLower + BIN_SIZE;
  } else {
    minYUpper = round;
    minYLower = round - BIN_SIZE;
  }

  round = Math.round(maxY / BIN_SIZE) * BIN_SIZE;
  var maxYLower, maxYUpper;
  if (round < maxY) {
    maxYLower = round;
    maxYUpper = maxYLower + BIN_SIZE;
  } else {
    maxYUpper = round;
    maxYLower = round - BIN_SIZE;
  }
  if (minYLower > maxYLower) {
    maxYLower = minYLower;
  }

  round = Math.round(minZ / BIN_SIZE) * BIN_SIZE;
  var minZLower, minZUpper;
  if (round <= minZ) {
    minZLower = round;
    minZUpper = minZLower + BIN_SIZE;
  } else {
    minZUpper = round;
    minZLower = round - BIN_SIZE;
  }

  round = Math.round(maxZ / BIN_SIZE) * BIN_SIZE;
  var maxZLower, maxZUpper;
  if (round < maxZ) {
    maxZLower = round;
    maxZUpper = maxZLower + BIN_SIZE;
  } else {
    maxZUpper = round;
    maxZLower = round - BIN_SIZE;
  }
  if (minZLower > maxZLower) {
    maxZLower = minZLower;
  }

  for (var x = minXLower; x <= maxXLower; x += BIN_SIZE) {
    for (var y = minYLower; y <= maxYLower; y += BIN_SIZE) {
      for (var z = minZLower; z <= maxZLower; z += BIN_SIZE) {
        if (!this.bin.has(x)) {
          this.bin.set(x, new Map());
        }
        if (!this.bin.get(x).has(y)) {
          this.bin.get(x).set(y, new Map());
        }
        if (!this.bin.get(x).get(y).has(z)) {
          this.bin.get(x).get(y).set(z, new Map());
        }
        this.bin.get(x).get(y).get(z).set(obj, true);

        if (!obj.binInfo.has(x)) {
          obj.binInfo.set(x, new Map());
        }
        if (!obj.binInfo.get(x).has(y)) {
          obj.binInfo.get(x).set(y, new Map());
        }
        obj.binInfo.get(x).get(y).set(z, true);
      }
    }
  }
};

Nearby.prototype.query = function (x, y, z) {
  var BIN_SIZE = this.binSize;

  var rX = Math.round(x / BIN_SIZE) * BIN_SIZE;
  var rY = Math.round(y / BIN_SIZE) * BIN_SIZE;
  var rZ = Math.round(z / BIN_SIZE) * BIN_SIZE;

  var minX, maxX;
  if (rX <= x) {
    minX = rX;
    maxX = rX + BIN_SIZE;
  } else {
    maxX = rX;
    minX = rX - BIN_SIZE;
  }
  var minY, maxY;
  if (rY <= y) {
    minY = rY;
    maxY = rY + BIN_SIZE;
  } else {
    maxY = rY;
    minY = rY - BIN_SIZE;
  }
  var minZ, maxZ;
  if (rZ <= z) {
    minZ = rZ;
    maxZ = rZ + BIN_SIZE;
  } else {
    maxZ = rZ;
    minZ = rZ - BIN_SIZE;
  }

  var result = this.reusableResultMap;
  result.clear();

  for (var xDiff = -BIN_SIZE; xDiff <= BIN_SIZE; xDiff += BIN_SIZE) {
    for (var yDiff = -BIN_SIZE; yDiff <= BIN_SIZE; yDiff += BIN_SIZE) {
      for (var zDiff = -BIN_SIZE; zDiff <= BIN_SIZE; zDiff += BIN_SIZE) {
        var keyX = minX + xDiff;
        var keyY = minY + yDiff;
        var keyZ = minZ + zDiff;
        if (this.bin.has(keyX) && this.bin.get(keyX).has(keyY)) {
          var res = this.bin.get(keyX).get(keyY).get(keyZ);
          if (res) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = res.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var obj = _step.value;

                result.set(obj, true);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
        }
      }
    }
  }

  return result;
};

Nearby.prototype.delete = function (obj) {
  var binInfo = obj.binInfo;

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = binInfo.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var x = _step2.value;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = binInfo.get(x).keys()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var y = _step4.value;
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = binInfo.get(x).get(y).keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var z = _step5.value;

              if (this.bin.has(x) && this.bin.get(x).has(y) && this.bin.get(x).get(y).has(z)) {
                this.bin.get(x).get(y).get(z).delete(obj);
                if (this.bin.get(x).get(y).get(z).size == 0) {
                  this.bin.get(x).get(y).delete(z);
                }
                if (this.bin.get(x).get(y).size == 0) {
                  this.bin.get(x).delete(y);
                }
                if (this.bin.get(x).size == 0) {
                  this.bin.delete(x);
                }
              }
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = binInfo.keys()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var x = _step3.value;

      binInfo.delete(x);
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3.return) {
        _iterator3.return();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }
};

Nearby.prototype.update = function (obj, x, y, z, width, height, depth) {
  obj.box.setFromCenterAndSize(x, y, z, width, height, depth);

  this.delete(obj);
  this.insert(obj);
};

var vectorPool$3 = new VectorPool(10);
var mathUtils = new MathUtils();

var Quaternion = function Quaternion(x, y, z, w) {
  this.set(x || 0, y || 0, z || 0, w === undefined ? 1 : w);
};

Quaternion.prototype.set = function (x, y, z, w) {
  this.x = x;
  this.y = y;
  this.z = z;
  this.w = w;

  return this;
};

Quaternion.prototype.copy = function (quaternion) {
  this.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);

  return this;
};

Quaternion.prototype.clone = function () {
  return new Quaternion().copy(this);
};

Quaternion.prototype.dot = function (quaternion) {
  return this.x * quaternion.x + this.y * quaternion.y + this.z * quaternion.z + this.w * quaternion.w;
};

Quaternion.prototype.radialDistanceTo = function (quaternion) {
  return 2 * Math.acos(Math.abs(mathUtils.clamp(this.dot(quaternion), -1, 1)));
};

Quaternion.prototype.getLength = function () {
  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
};

Quaternion.prototype.normalize = function () {
  var len = this.getLength();

  if (len != 0) {
    return this.set(this.x / len, this.y / len, this.z / len, this.w / len);
  }

  return this.set(0, 0, 0, 1);
};

Quaternion.prototype.sphericalLinearInterpolation = function (quaternion, t) {
  if (t == 0) {
    return this;
  }
  if (t == 1) {
    return this.copy(quaternion);
  }

  var x = this.x,
      y = this.y,
      z = this.z,
      w = this.w;

  var cosHalfTheta = w * quaternion.w + x * quaternion.x + y * quaternion.y + z * quaternion.z;

  if (cosHalfTheta < 0) {
    this.set(-quaternion.x, -quaternion.y, -quaternion.z, -quaternion.w);
    cosHalfTheta = -cosHalfTheta;
  } else {
    this.copy(quaternion);
  }

  if (cosHalfTheta >= 1) {
    return this.set(x, y, z, w);
  }

  var sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;

  if (sqrSinHalfTheta < Number.EPSILON) {
    var s = 1 - t;
    return this.set(s * x + t * this.x, s * y + t * this.y, s * z + t * this.z, s * w + t * this.w).normalize();
  }

  var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
  var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
  var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
  var ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

  return this.set(x * ratioA + this.x * ratioB, y * ratioA + this.y * ratioB, z * ratioA + this.z * ratioB, w * ratioA + this.w * ratioB);
};

Quaternion.prototype.rotateTowards = function (quaternion, step) {
  var radialDistance = this.radialDistanceTo(quaternion);
  if (radialDistance == 0) {
    return this;
  }

  return this.sphericalLinearInterpolation(quaternion, Math.min(1, step / radialDistance));
};

Quaternion.prototype.setFromVectors = function (vFrom, vTo) {
  var vFromNormalized = vectorPool$3.get().copy(vFrom).normalize();
  var vToNormalized = vectorPool$3.get().copy(vTo).normalize();

  var r = vFromNormalized.dot(vToNormalized) + 1;

  if (r < Number.EPSILON) {
    if (Math.abs(vFromNormalized.x) > Math.abs(vToNormalized.z)) {
      this.set(-vFromNormalized.y, vFromNormalized.x, 0, 0);
    } else {
      this.set(0, -vFromNormalized.z, vFromNormalized.y, 0);
    }
  } else {
    this.set(vFromNormalized.y * vToNormalized.z - vFromNormalized.z * vToNormalized.y, vFromNormalized.z * vToNormalized.x - vFromNormalized.x * vToNormalized.z, vFromNormalized.x * vToNormalized.y - vFromNormalized.y * vToNormalized.x, r);
  }

  return this.normalize();
};

var quaternion = new Quaternion();
var quaternion2 = new Quaternion();
var delta = 1 / 60;
var vectorPool$2 = new VectorPool(10);

var Entity = function Entity(id, center, size) {
  this.id = id;
  this.size = size.clone();
  this.position = center.clone();

  this.world = null;

  this.box = new Box(center, size);

  this.nearbyObject = null;

  this.maxSpeed = Infinity;
  this.velocity = new Vector3D();

  this.hasLookTarget = false;
  this.lookTarget = new Vector3D();

  this.lookSpeed = 0.1;

  this.lookDirection = new Vector3D(0, 0, -1);

  this.isHidden = false;

  this.limitVelocity = true;
};

Entity.prototype.update = function () {

  if (this.isHidden) {
    return;
  }

  var speed = this.velocity.getLength();
  if (this.limitVelocity && speed > this.maxSpeed) {
    this.velocity.copy(this.velocity.normalize().multiplyScalar(this.maxSpeed));
  }

  var vect = vectorPool$2.get().copy(this.velocity).multiplyScalar(delta);
  this.setPosition(this.position.add(vect));

  if (this.hasLookTarget) {
    var desiredDirection = vectorPool$2.get().copy(this.lookTarget).sub(this.position);
    var desiredQuaternion = quaternion.setFromVectors(this.lookDirection, desiredDirection);
    quaternion2.set(0, 0, 0, 1);
    var v = vectorPool$2.get().copy(this.lookDirection).applyQuaternion(quaternion2.rotateTowards(quaternion, this.lookSpeed));
    this.setLookDirection(v);
  }
};

Entity.prototype.setLimitVelocity = function (val) {
  this.limitVelocity = val;
};

Entity.prototype.setPositionAndSize = function (position, size) {

  if (this.isHidden) {
    return false;
  }

  this.setPosition(position, true);
  this.setSize(size);

  return true;
};

Entity.prototype.setSize = function (size, skipWorldUpdate) {

  if (this.isHidden) {
    return false;
  }

  this.size.copy(size);
  this.box.setFromCenterAndSize(this.position, size);

  if (this.world && !skipWorldUpdate) {
    this.world.updateEntity(this, this.position, this.size);
  }

  return true;
};

Entity.prototype.setPosition = function (position, skipWorldUpdate) {

  if (this.isHidden) {
    return false;
  }

  this.position.copy(position);
  this.box.setFromCenterAndSize(position, this.size);

  if (this.world && !skipWorldUpdate) {
    this.world.updateEntity(this, this.position, this.size);
  }

  return true;
};

Entity.prototype.setLookDirection = function (direction) {
  this.lookDirection.copy(vectorPool$2.get().copy(direction).normalize());

  if (this.world) {
    this.world.onLookDirectionUpdated(this);
  }
};

Entity.prototype.executeForEachCloseEntity = function (func) {
  if (!this.world) {
    return;
  }
  var res = this.world.getNearbyObjects(this.position);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = res[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var obj = _step.value;

      if (obj.id != this.id) {
        if (func(this.world.getEntityByID(obj.id))) {
          return;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

Entity.prototype.setLookTarget = function (target) {
  this.lookTarget.copy(target);
  this.hasLookTarget = true;
};

Entity.prototype.unsetLookTarget = function () {
  this.hasLookTarget = false;
};

Entity.prototype.isNearTo = function (entity) {
  var result = false;

  this.executeForEachCloseEntity(function (candidate) {
    if (candidate === entity) {
      result = true;
      return true;
    }
  });

  return result;
};

var VERTEX_ENTITY_SIZE = new Vector3D(1, 1, 1);

var Vertex = function Vertex(positionVector, graph) {

  var position = positionVector.clone();

  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });

  Entity.call(this, 'vertex#' + uuid, position, VERTEX_ENTITY_SIZE);

  this.position = position;
  this.graph = graph;
};

Vertex.prototype = Object.create(Entity.prototype);

Object.defineProperty(Vertex.prototype, 'constructor', { value: Vertex, enumerable: false, writable: true });

var World = function World(width, height, depth, binSize) {

  this.width = width;
  this.height = height;
  this.depth = depth;

  this.nearby = new Nearby(width, height, depth, binSize);

  this.entititesByID = {};

  this.gravity = 0;
};

World.prototype.setGravity = function (gravity) {
  this.gravity = gravity;
};

World.prototype.getEntityByID = function (entityID) {
  return this.entititesByID[entityID] || null;
};

World.prototype.insertGraph = function (graph) {
  if (graph.world) {
    return;
  }

  var self = this;

  graph.forEachVertex(function (x, y, z) {
    var vertex = new Vertex(new Vector3D(x, y, z), graph);
    self.insertEntity(vertex);
    graph.vertexIDs.push(vertex.id);
  });

  graph.world = this;
};

World.prototype.removeGraph = function (graph) {
  if (!graph.world) {
    return;
  }

  for (var i = 0; i < graph.vertexIDs.length; i++) {
    var vertexID = graph.vertexIDs[i];
    var entity = this.getEntityByID(vertexID);
    this.removeEntity(entity);
  }

  graph.world = null;
  graph.vertexIDs = [];
};

World.prototype.hideEntity = function (entity) {

  if (!this.entititesByID[entity.id] || entity.isHidden) {
    return false;
  }

  this.nearby.delete(entity.nearbyObject);
  entity.isHidden = true;

  if (this.onEntityHidden) {
    this.onEntityHidden(entity);
  }

  return true;
};

World.prototype.showEntity = function (entity) {

  if (!this.entititesByID[entity.id] || !entity.isHidden) {
    return false;
  }

  this.nearby.insert(entity.nearbyObject);
  entity.isHidden = false;

  if (this.onEntityShown) {
    this.onEntityShown(entity);
  }

  return true;
};

World.prototype.insertEntity = function (entity) {

  this.entititesByID[entity.id] = entity;

  var center = entity.position;
  var size = entity.size;

  var nearbyBox = this.nearby.createBox(center.x, center.y, center.z, size.x, size.y, size.z);
  var nearbyObj = this.nearby.createObject(entity.id, nearbyBox);
  this.nearby.insert(nearbyObj);

  entity.world = this;
  entity.nearbyObject = nearbyObj;

  entity.lastWorldPosition = center.clone();
  entity.lastWorldSize = size.clone();

  if (this.onEntityInserted) {
    this.onEntityInserted(entity);
  }
};

World.prototype.updateEntity = function (entity, position, size) {

  if (entity.isHidden) {
    return;
  }

  if (entity.lastWorldPosition.eql(position) && entity.lastWorldSize.eql(size)) {
    return;
  }

  this.nearby.update(entity.nearbyObject, position.x, position.y, position.z, size.x, size.y, size.z);

  if (this.onEntityUpdated) {
    this.onEntityUpdated(entity);
  }

  entity.lastWorldPosition.copy(position);
  entity.lastWorldSize.copy(size);
};

World.prototype.onLookDirectionUpdated = function (entity) {
  if (this.onEntityLookDirectionUpdated) {
    this.onEntityLookDirectionUpdated(entity);
  }
};

World.prototype.removeEntity = function (entity) {
  delete this.entititesByID[entity.id];
  this.nearby.delete(entity.nearbyObject);

  if (this.onEntityRemoved) {
    this.onEntityRemoved(entity);
  }

  delete entity.lastWorldPosition;
  delete entity.lastWorldSize;
};

World.prototype.getNearbyObjects = function (position) {
  return this.nearby.query(position.x, position.y, position.z).keys();
};

World.prototype.forEachEntity = function (func) {
  for (var key in this.entititesByID) {
    var entity = this.entititesByID[key];
    func(entity);
  }
};

var mathUtils$1 = new MathUtils();

var Path = function Path(options) {

  options = options || {};

  this.index = 0;

  this.length = 0;
  this.jumpDescriptorLength = 0;

  this.loop = !!options.loop;
  this.rewind = !!options.rewind;

  this.isRewinding = false;
  this.isFinished = false;

  this.waypoints = [];
  this.jumpDescriptors = [];

  this.finishCallbacksByID = {};

  if (options.fixedLength) {
    for (var i = 0; i < options.fixedLength; i++) {
      this.waypoints.push(new Vector3D());
      this.jumpDescriptors.push(null);
    }
  }

  this.options = JSON.parse(JSON.stringify(options));
};

Path.prototype.clone = function () {
  var cloned = new Path(this.options);

  if (!this.options.fixedLength) {
    for (var i = 0; i < this.waypoints.length; i++) {
      cloned.addWaypoint(this.waypoints[i]);
    }

    for (var i = 0; i < this.jumpDescriptors.length; i++) {
      cloned.addJumpDescriptor(this.jumpDescriptors[i]);
    }
  } else {
    for (var i = 0; i < this.length; i++) {
      cloned.insertWaypoint(this.waypoints[i]);
    }

    for (var i = 0; i < this.jumpDescriptorLength; i++) {
      cloned.insertJumpDescriptor(this.jumpDescriptors[i]);
    }
  }

  return cloned;
};

Path.prototype.restart = function () {
  this.isRewinding = false;
  this.isFinished = false;
  this.index = 0;
};

Path.prototype.insertJumpDescriptor = function (jumpDescriptor) {
  this.jumpDescriptors[this.jumpDescriptorLength++] = jumpDescriptor;
};

Path.prototype.addJumpDescriptor = function (jumpDescriptor) {
  var takeoffPosition = jumpDescriptor.takeoffPosition;
  var landingPosition = jumpDescriptor.landingPosition;

  var takeoffIndex = this.getWaypointIndex(takeoffPosition);

  if (takeoffIndex == null) {
    return false;
  }

  var landingIndex = this.getWaypointIndex(landingPosition);
  if (landingIndex == null) {
    return false;
  }

  if (takeoffIndex >= landingIndex) {
    return false;
  }

  this.jumpDescriptors.push(jumpDescriptor);

  this.jumpDescriptorLength++;

  return true;
};

Path.prototype.getWaypointIndex = function (waypoint) {
  var length = this.length;
  var index = this.waypoints.findIndex(function (wp, index) {
    return index < length && wp.eql(waypoint);
  });

  if (index == -1) {
    return null;
  }

  return index;
};

Path.prototype.insertWaypoint = function (waypoint) {
  this.waypoints[this.length++].copy(waypoint);
};

Path.prototype.addWaypoint = function (waypoint) {
  this.waypoints.push(waypoint.clone());
  this.length++;
};

Path.prototype.getCurrentWaypoint = function () {
  return this.isFinished ? false : this.waypoints[this.index] || false;
};

Path.prototype.addFinishCallback = function (fn) {
  var id = mathUtils$1.uuidv4();

  this.finishCallbacksByID[id] = fn;

  return id;
};

Path.prototype.removeFinishCallback = function (callbackID) {
  if (this.finishCallbacksByID[callbackID]) {
    delete this.finishCallbacksByID[callbackID];
    return true;
  }

  return false;
};

Path.prototype.onFinished = function () {
  var allCallbacks = this.finishCallbacksByID;
  for (var id in allCallbacks) {
    allCallbacks[id]();
  }
};

Path.prototype.next = function () {
  if (this.isFinished) {
    return;
  }

  var len = this.length;

  if (!this.isRewinding) {
    this.index++;

    if (this.index == len) {

      if (this.rewind) {
        this.index = len - 2;
        this.isRewinding = true;
      } else if (this.loop) {
        this.index = 0;
      } else {
        this.isFinished = true;
        this.onFinished();
      }
    }
  } else {

    this.index--;

    if (this.index == -1) {
      if (this.loop) {
        this.index = 1;
        this.isRewinding = false;
      } else {
        this.isFinished = true;
        this.onFinished();
      }
    }
  }
};

Path.prototype.getRandomWaypoint = function () {
  return this.waypoints[Math.floor(Math.random() * this.length)] || null;
};

var Edge = function Edge(fromVertex, toVertex) {
  this.fromVertex = fromVertex.clone();
  this.toVertex = toVertex.clone();
  this.cost = fromVertex.clone().sub(toVertex).getLength();

  this.jumpDescriptor = null;
};

Edge.prototype.clone = function () {
  return new Edge(this.fromVertex, this.toVertex);
};

var Graph = function Graph() {

  this.world = null;

  this.connections = {};

  this.totalVertexCount = 0;

  this.vertexIDs = [];
};

Graph.prototype.clone = function () {
  var cloned = new Graph();

  this.forEachVertex(function (x, y, z) {
    cloned.addVertex(new Vector3D(x, y, z));
  });

  this.forEachEdge(function (edge) {
    cloned.addEdge(edge.fromVertex, edge.toVertex);
  });

  this.forEachEdge(function (edge) {
    if (edge.jumpDescriptor) {
      cloned.addJumpDescriptor(edge.jumpDescriptor);
    }
  });

  return cloned;
};

Graph.prototype.findClosestVertexToPoint = function (pointVector) {

  var world = this.world;

  if (!world) {
    return null;
  }

  var dist = Infinity,
      closest = null;

  var res = this.world.getNearbyObjects(pointVector);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = res[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var obj = _step.value;

      var entity = world.getEntityByID(obj.id);

      if (entity instanceof Vertex && entity.graph === this) {

        var curDist = pointVector.getDistanceSq(entity.position);
        if (curDist < dist) {
          closest = entity;
          dist = curDist;
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (closest) {
    return closest.position;
  }

  return null;
};

Graph.prototype.addVertex = function (vertex) {

  if (this.hasVertex(vertex)) {
    return false;
  }

  var x = vertex.x;
  var y = vertex.y;
  var z = vertex.z;

  if (!this.connections[x]) {
    this.connections[x] = {};
  }

  if (!this.connections[x][y]) {
    this.connections[x][y] = {};
  }

  if (!this.connections[x][y][z]) {
    this.connections[x][y][z] = [];
  }

  this.totalVertexCount++;

  return true;
};

Graph.prototype.removeVertex = function (vertex) {

  if (!this.hasVertex(vertex)) {
    return false;
  }

  var x = vertex.x;
  var y = vertex.y;
  var z = vertex.z;

  delete this.connections[x][y][z];

  if (Object.keys(this.connections[x][y]).length == 0) {
    delete this.connections[x][y];
  }

  if (Object.keys(this.connections[x]).length == 0) {
    delete this.connections[x];
  }

  for (var x in this.connections) {
    for (var y in this.connections[x]) {
      for (var z in this.connections[x][y]) {
        var ary = this.connections[x][y][z];
        var index = -1;
        for (var i = 0; i < ary.length; i++) {
          var edge = ary[i];
          var to = edge.toVertex;
          if (to.x == vertex.x && to.y == vertex.y && to.z == vertex.z) {
            index = i;
            break;
          }
        }
        if (index != -1) {
          ary.splice(index, 1);
          this.connections[x][y][z] = ary;
        }
      }
    }
  }

  this.totalVertexCount--;

  return true;
};

Graph.prototype.hasVertex = function (vertex) {
  var x = vertex.x;
  var y = vertex.y;
  var z = vertex.z;

  return !!(this.connections[x] && this.connections[x][y] && this.connections[x][y][z]);
};

Graph.prototype.addEdge = function (fromVertex, toVertex) {
  if (!this.hasVertex(fromVertex) || !this.hasVertex(toVertex)) {
    return false;
  }

  var edges = this.connections[fromVertex.x][fromVertex.y][fromVertex.z];

  for (var i = 0; i < edges.length; i++) {
    var to = edges[i].toVertex;
    if (to.x == toVertex.x && to.y == toVertex.y && to.z == toVertex.z) {
      return false;
    }
  }

  var edge = new Edge(fromVertex, toVertex);
  edges.push(edge);

  return true;
};

Graph.prototype.addJumpDescriptor = function (jumpDescriptor) {
  var fromVertex = jumpDescriptor.takeoffPosition;
  var toVertex = jumpDescriptor.landingPosition;
  if (!this.hasVertex(fromVertex) || !this.hasVertex(toVertex)) {
    return false;
  }

  var edges = this.connections[fromVertex.x][fromVertex.y][fromVertex.z];
  var edge = null;

  for (var i = 0; i < edges.length; i++) {
    var to = edges[i].toVertex;
    if (to.x == toVertex.x && to.y == toVertex.y && to.z == toVertex.z) {
      edge = edges[i];
      break;
    }
  }

  if (edge) {
    edge.jumpDescriptor = jumpDescriptor;
  } else {
    edge = new Edge(fromVertex, toVertex);
    edge.jumpDescriptor = jumpDescriptor;
    edges.push(edge);
  }

  return true;
};

Graph.prototype.removeEdge = function (fromVertex, toVertex) {
  if (!this.hasVertex(fromVertex) || !this.hasVertex(toVertex)) {
    return false;
  }

  var ary = this.connections[fromVertex.x][fromVertex.y][fromVertex.z];

  var index = -1;
  for (var i = 0; i < ary.length; i++) {
    var edge = ary[i];
    var to = edge.toVertex;
    if (to.x == toVertex.x && to.y == toVertex.y && to.z == toVertex.z) {
      index = i;
      break;
    }
  }

  if (index == -1) {
    return false;
  }

  ary.splice(index, 1);
  this.connections[fromVertex.x][fromVertex.y][fromVertex.z] = ary;

  return true;
};

Graph.prototype.forEachNeighbor = function (vertex, fn) {
  if (!this.hasVertex(vertex)) {
    return;
  }

  var ary = this.connections[vertex.x][vertex.y][vertex.z];

  for (var i = 0; i < ary.length; i++) {
    var edge = ary[i];
    fn(edge.toVertex, edge.cost, edge.jumpDescriptor);
  }
};

Graph.prototype.forEachVertex = function (fn) {
  for (var x in this.connections) {
    for (var y in this.connections[x]) {
      for (var z in this.connections[x][y]) {
        fn(parseFloat(x), parseFloat(y), parseFloat(z));
      }
    }
  }
};

Graph.prototype.forEachEdge = function (fn) {
  for (var x in this.connections) {
    for (var y in this.connections[x]) {
      for (var z in this.connections[x][y]) {
        var edges = this.connections[x][y][z];
        for (var i = 0; i < edges.length; i++) {
          fn(edges[i]);
        }
      }
    }
  }
};

var MinHeap = function MinHeap(maxNodeCount) {
  this.data = [];
  for (var i = 0; i < maxNodeCount; i++) {
    this.data.push(null);
  }

  this.length = 0;

  this.HEAP_CHECK_RESULT_OK = 0;
  this.HEAP_CHECK_RESULT_LEFT = 1;
  this.HEAP_CHECK_RESULT_RIGHT = 2;
};

MinHeap.prototype.reset = function () {
  for (var i = 0; i < this.data.length; i++) {
    this.data[i] = null;
  }

  this.length = 0;
};

MinHeap.prototype.peek = function () {
  return this.data[0];
};

MinHeap.prototype.getParentIndex = function (childIndex) {
  return Math.floor(childIndex / 2);
};

MinHeap.prototype.getLeftChildIndex = function (rootIndex) {
  return this.getRightChildIndex(rootIndex) - 1;
};

MinHeap.prototype.getRightChildIndex = function (rootIndex) {
  return 2 * (rootIndex + 1);
};

MinHeap.prototype.insert = function (heapNode) {

  if (this.data.length == this.length) {
    return false;
  }

  var curNodeIndex = this.length;
  var curParentIndex = this.getParentIndex(this.length);

  this.data[curNodeIndex] = heapNode;

  var parent = this.data[curParentIndex];
  while (parent && heapNode.priority < parent.priority) {
    this.data[curParentIndex] = heapNode;
    this.data[curNodeIndex] = parent;

    curNodeIndex = curParentIndex;
    curParentIndex = this.getParentIndex(curNodeIndex);
    parent = this.data[curParentIndex];
  }

  this.length++;
  return true;
};

MinHeap.prototype.remove = function (node) {
  var index = this.data.indexOf(node);

  if (index == -1) {
    return false;
  }

  var lastIndex = this.length - 1;
  this.swap(index, lastIndex);
  this.data[lastIndex] = null;
  this.length--;

  this.reconstruct(index);

  return true;
};

MinHeap.prototype.heapCheck = function (rootIndex) {
  var root = this.data[rootIndex];

  if (!root) {
    return this.HEAP_CHECK_RESULT_OK;
  }

  var leftIndex = this.getLeftChildIndex(rootIndex);
  var rightIndex = this.getRightChildIndex(rootIndex);

  var left = this.data[leftIndex];
  var right = this.data[rightIndex];
  if (!left && !right) {
    return this.HEAP_CHECK_RESULT_OK;
  } else if (!right) {
    if (root.priority <= left.priority) {
      return this.HEAP_CHECK_RESULT_OK;
    } else {
      return this.HEAP_CHECK_RESULT_LEFT;
    }
  }

  if (root.priority <= left.priority && root.priority <= right.priority) {
    return this.HEAP_CHECK_RESULT_OK;
  }

  if (left.priority <= root.priority && left.priority <= right.priority) {
    return this.HEAP_CHECK_RESULT_LEFT;
  }

  return this.HEAP_CHECK_RESULT_RIGHT;
};

MinHeap.prototype.swap = function (index1, index2) {
  var val1 = this.data[index1];
  var val2 = this.data[index2];

  this.data[index1] = val2;
  this.data[index2] = val1;
};

MinHeap.prototype.pop = function () {
  if (this.length == 0) {
    return false;
  }

  var minData = this.data[0];

  var lastIndex = this.length - 1;
  this.data[0] = this.data[lastIndex];
  this.data[lastIndex] = null;
  this.length--;

  this.reconstruct(0);

  return minData;
};

MinHeap.prototype.reconstruct = function (rootIndex) {
  var heapCheckResult = this.heapCheck(rootIndex);
  while (heapCheckResult != this.HEAP_CHECK_RESULT_OK) {
    if (heapCheckResult == this.HEAP_CHECK_RESULT_LEFT) {
      var leftIndex = this.getLeftChildIndex(rootIndex);
      this.swap(rootIndex, leftIndex);
      rootIndex = leftIndex;
    } else {
      var rightIndex = this.getRightChildIndex(rootIndex);
      this.swap(rootIndex, rightIndex);
      rootIndex = rightIndex;
    }

    heapCheckResult = this.heapCheck(rootIndex);
  }
};

MinHeap.prototype.hasNode = function (node) {
  return this.data.indexOf(node) >= 0;
};

var vectorPool$4 = new VectorPool(10);

var mathUtils$2 = new MathUtils();

var AStar = function AStar(graph) {

  var path = new Path({ fixedLength: graph.totalVertexCount });

  var heapNodes = {};

  graph.forEachVertex(function (x, y, z) {
    if (!heapNodes[x]) {
      heapNodes[x] = {};
    }

    if (!heapNodes[x][y]) {
      heapNodes[x][y] = {};
    }

    if (!heapNodes[x][y][z]) {
      heapNodes[x][y][z] = { priority: 0, parent: null, x: parseFloat(x), y: parseFloat(y), z: parseFloat(z), closedTag: null, parentTag: null, priorityTag: null, jumpDescriptor: null };
    }
  });

  this.heapNodes = heapNodes;
  this.path = path;
  this.graph = graph;
  this.heap = new MinHeap(graph.totalVertexCount);

  this._internalID = mathUtils$2.uuidv4();

  this.searchID = 0;
};

AStar.prototype.getHeapNode = function (x, y, z, heapNodes) {
  var nx = heapNodes ? heapNodes[x] : this.heapNodes[x];
  if (nx) {
    var ny = nx[y];
    if (ny) {
      return ny[z] || null;
    }
    return null;
  }
  return null;
};

AStar.prototype.isNodeBelongToVector = function (node, vector) {
  return node === this.getHeapNode(vector.x, vector.y, vector.z);
};

AStar.prototype.generatePath = function (endVector) {

  var path = this.path;
  path.length = 0;

  var vec = endVector;
  var heapNode = this.getHeapNode(vec.x, vec.y, vec.z);

  while (heapNode) {
    path.insertWaypoint(vec);

    var jumpDescriptor = heapNode.jumpDescriptor;
    if (jumpDescriptor) {
      path.insertJumpDescriptor(jumpDescriptor);
    }

    var parentTag = heapNode.parentTag;
    heapNode = heapNode.parent;
    if (heapNode && parentTag != this.searchID) {
      heapNode = null;
    }

    if (heapNode) {
      vec = vectorPool$4.get().set(heapNode.x, heapNode.y, heapNode.z);
    }
  }

  path.isRewinding = true;
  path.index = path.length - 1;
  path.isFinished = false;

  if (this.onPathConstructed) {
    this.onPathConstructed();
  }

  return path;
};

AStar.prototype.markNodeAsClosed = function (node, searchID) {
  node.closedTag = searchID;
};

AStar.prototype.isNodeClosed = function (node, searchID) {
  return node.closedTag === searchID;
};

AStar.prototype.findShortestPath = function (fromVector, toVector) {

  var heapNodes = this.heapNodes;

  this.searchID++;

  var searchID = this.searchID;

  var heap = this.heap;

  heap.reset();

  var graph = this.graph;
  if (!graph.hasVertex(fromVector) || !graph.hasVertex(toVector)) {
    return false;
  }

  var getHeapNode = this.getHeapNode;
  var isNodeClosed = this.isNodeClosed;
  var markNodeAsClosed = this.markNodeAsClosed;

  var heapNode = this.getHeapNode(fromVector.x, fromVector.y, fromVector.z);
  var vec = vectorPool$4.get();

  heap.insert(heapNode);

  while (heapNode) {
    if (this.isNodeBelongToVector(heapNode, toVector)) {
      return this.generatePath(toVector);
    }

    markNodeAsClosed(heapNode, searchID);

    vec.set(heapNode.x, heapNode.y, heapNode.z);
    graph.forEachNeighbor(vec, function (neighborVec, cost, jumpDescriptor) {

      var neighborHeapNode = getHeapNode(neighborVec.x, neighborVec.y, neighborVec.z, heapNodes);

      var heuristicCost = neighborVec.getDistanceSq(toVector);

      if (!isNodeClosed(neighborHeapNode, searchID)) {
        neighborHeapNode.priority = cost + heuristicCost;
        neighborHeapNode.priorityTag = searchID;
        neighborHeapNode.parent = heapNode;
        neighborHeapNode.parentTag = searchID;
        neighborHeapNode.jumpDescriptor = jumpDescriptor;
        markNodeAsClosed(neighborHeapNode, searchID);
        heap.insert(neighborHeapNode);
      }

      if (heap.hasNode(neighborHeapNode)) {
        var currentPriority = heuristicCost + cost;

        if (currentPriority < neighborHeapNode.priority && neighborHeapNode.priorityTag == searchID) {
          neighborHeapNode.priority = currentPriority;
          neighborHeapNode.parent = heapNode;
          neighborHeapNode.parentTag = searchID;
          neighborHeapNode.jumpDescriptor = jumpDescriptor;
          heap.remove(neighborHeapNode);
          heap.insert(neighborHeapNode);
        }
      }
    });

    heapNode = heap.pop();
  }

  return false;
};

var Logger = function Logger() {

  this.logMethod = console.log;

  this.isEnabled = false;

  this.lastMessageMap = {};
};

Logger.prototype.enable = function () {
  this.isEnabled = true;
};

Logger.prototype.disable = function () {
  this.isEnabled = false;
};

Logger.prototype.log = function (component, msg, id) {
  if (!this.isEnabled || this.lastMessageMap[id] == msg) {
    return;
  }

  this.logMethod("[" + component + "]: " + msg + " (" + id + ")");

  this.lastMessageMap[id] = msg;
};

var logger = new Logger();

var LOGGER_COMPONENT_NAME = "Steerable";
var LOG_NOT_INSERTED_TO_WORLD = "Not inserted to a world.";
var LOG_HAS_NO_BEHAVIOR = "Has no behavior.";
var LOG_JUMP_COMPLETED = "Jump completed.";
var LOG_JUMP_READY = "Jump ready.";
var LOG_EQUATION_CANNOT_BE_SOLVED = "Equation cannot be solved.";
var LOG_JUMP_INITIATED = "Jump initiated.";
var LOG_NO_JUMP_BEHAVIOR_SET = "No jump behavior set.";
var LOG_IS_HIDDEN = "Steerable is hidden.";

var delta$1 = 1 / 60;
var vectorPool$5 = new VectorPool(10);

var Steerable = function Steerable(id, center, size) {
  Entity.call(this, id, center, size);

  this.hasTargetPosition = false;
  this.hasTargetEntity = false;
  this.hasHideTargetEntity = false;

  this.targetPosition = new Vector3D();
  this.targetEntity = null;
  this.hideTargetEntity = null;

  this.linearAcceleration = new Vector3D();
  this.maxAcceleration = Infinity;

  this.isJumpInitiated = false;
  this.isJumpReady = false;
  this.isJumpTakenOff = false;

  this.jumpSpeed = Infinity;
  this.jumpTime = 0;
};

Steerable.prototype = Object.create(Entity.prototype);

Steerable.prototype.update = function () {

  if (this.isHidden) {
    logger.log(LOGGER_COMPONENT_NAME, LOG_IS_HIDDEN, this.id);
    return;
  }

  if (!this.world) {
    logger.log(LOGGER_COMPONENT_NAME, LOG_NOT_INSERTED_TO_WORLD, this.id);
    return;
  }

  if (!this.behavior) {
    logger.log(LOGGER_COMPONENT_NAME, LOG_HAS_NO_BEHAVIOR, this.id);
    return;
  }

  var steerResult = this.behavior.compute(this);

  this.linearAcceleration.copy(steerResult.linear);

  var len = this.linearAcceleration.getLength();
  if (len > this.maxAcceleration) {
    this.linearAcceleration.copy(this.linearAcceleration.normalize().multiplyScalar(this.maxAcceleration));
  }

  if (this.isJumpTakenOff) {
    this.linearAcceleration.y += this.world.gravity;
    this.jumpTime += delta$1;
    if (this.jumpTime >= this.jumpDescriptor.getEquationResult(this).time) {
      logger.log(LOGGER_COMPONENT_NAME, LOG_JUMP_COMPLETED, this.id);
      this.onJumpCompleted();
    }
  }

  var vect = vectorPool$5.get().copy(this.linearAcceleration).multiplyScalar(delta$1);
  this.velocity.add(vect);
  Entity.prototype.update.call(this);

  if (this.isJumpInitiated && !this.isJumpTakenOff && !this.isJumpReady) {
    var distToTakeoffPosition = vectorPool$5.get().copy(this.position).sub(this.jumpDescriptor.takeoffPosition).getLength();
    if (distToTakeoffPosition < this.jumpDescriptor.takeoffPositionSatisfactionRadius) {
      logger.log(LOGGER_COMPONENT_NAME, LOG_JUMP_READY, this.id);
      this.onJumpReady();
    }
  }
};

Steerable.prototype.setJumpBehavior = function (behavior) {
  if (this.isJumpInitiated) {
    return;
  }

  this.jumpBehavior = behavior;
};

Steerable.prototype.setBehavior = function (behavior) {
  if (this.isJumpInitiated) {
    return;
  }

  this.behavior = behavior;
};

Steerable.prototype.unsetTargetPosition = function () {
  if (this.isJumpInitiated) {
    return;
  }

  this.hasTargetPosition = false;
};

Steerable.prototype.setTargetPosition = function (position) {
  if (this.isJumpInitiated) {
    return;
  }

  this.targetPosition.copy(position);
  this.hasTargetPosition = true;
};

Steerable.prototype.setTargetEntity = function (entity) {
  if (this.isJumpInitiated) {
    return;
  }

  this.targetEntity = entity;
  this.hasTargetEntity = true;
};

Steerable.prototype.unsetTargetEntity = function () {
  if (this.isJumpInitiated) {
    return;
  }

  this.hasTargetEntity = false;
  this.targetEntity = null;
};

Steerable.prototype.setHideTargetEntity = function (entity) {
  if (this.isJumpInitiated) {
    return;
  }

  this.hideTargetEntity = entity;
  this.hasHideTargetEntity = true;
};

Steerable.prototype.unsetHideTargetEntity = function () {
  if (this.isJumpInitiated) {
    return;
  }

  this.hasHideTargetEntity = false;
  this.hideTargetEntity = null;
};

Steerable.prototype.jump = function (toTakeoffBehavior, jumpDescriptor) {

  var result = jumpDescriptor.solveQuadraticEquation(this);
  if (!result) {
    logger.log(LOGGER_COMPONENT_NAME, LOG_EQUATION_CANNOT_BE_SOLVED, this.id);
    return false;
  }

  this.isJumpInitiated = false;
  this.isJumpReady = false;
  this.isJumpTakenOff = false;

  this.unsetTargetEntity();
  this.unsetHideTargetEntity();

  this.setTargetPosition(jumpDescriptor.takeoffPosition);
  this.setBehavior(toTakeoffBehavior);

  this.jumpDescriptor = jumpDescriptor;

  this.isJumpInitiated = true;

  this.jumpTime = 0;

  logger.log(LOGGER_COMPONENT_NAME, LOG_JUMP_INITIATED, this.id);

  return true;
};

Steerable.prototype.cancelJump = function () {
  if (!(this.isJumpInitiated || this.isJumpReady || this.isJumpTakenOff)) {
    return false;
  }

  this.onJumpCompleted(true);

  return true;
};

Steerable.prototype.onJumpReady = function () {
  this.isJumpReady = true;
  this.isJumpInitiated = false;
  this.setBehavior(this.jumpBehavior);
  this.isJumpInitiated = true;

  if (!this.jumpBehavior) {
    logger.log(LOGGER_COMPONENT_NAME, LOG_NO_JUMP_BEHAVIOR_SET, this.id);
  }
};

Steerable.prototype.onJumpTakeOff = function () {
  this.isJumpTakenOff = true;

  var jumpDescriptor = this.jumpDescriptor;
  var equationResult = jumpDescriptor.getEquationResult(this);

  this.setLimitVelocity(false);

  this.velocity.set(equationResult.vx, this.jumpSpeed, equationResult.vz);
};

Steerable.prototype.onJumpCompleted = function (isCancel) {
  this.jumpTime = 0;
  this.isJumpInitiated = false;
  this.isJumpReady = false;
  this.isJumpTakenOff = false;

  if (!isCancel) {
    this.position.y = this.jumpDescriptor.landingPosition.y;
  }

  this.velocity.set(0, 0, 0);
  this.linearAcceleration.set(0, 0, 0);

  this.setLimitVelocity(true);

  if (!isCancel && this.jumpCompletionCallback) {
    this.jumpCompletionCallback(this);
  }
};

Steerable.prototype.setJumpCompletionListener = function (callback) {
  this.jumpCompletionCallback = callback;
};

Steerable.prototype.removeJumpCompletionListener = function () {
  this.jumpCompletionCallback = null;
};

Object.defineProperty(Steerable.prototype, 'constructor', { value: Steerable, enumerable: false, writable: true });

var SteerResult = function SteerResult() {
  this.linear = new Vector3D();
};

var mathUtils$3 = new MathUtils();

var JumpDescriptor = function JumpDescriptor(parameters) {
  this.takeoffPosition = parameters.takeoffPosition.clone();
  this.landingPosition = parameters.landingPosition.clone();
  this.takeoffPositionSatisfactionRadius = parameters.takeoffPositionSatisfactionRadius;

  this.delta = this.landingPosition.clone().sub(this.takeoffPosition);

  this.checkTimeResult = { vx: 0, vz: 0, isAchievable: false };

  this.cache = {};

  this._internalID = mathUtils$3.uuidv4();
};

JumpDescriptor.prototype.getEquationResult = function (steerable) {
  var jumpSpeed = steerable.jumpSpeed;
  var maxSpeed = steerable.maxSpeed;
  var gravity = steerable.world.gravity;

  var cache = this.cache;

  var obj;

  if (cache[jumpSpeed]) {
    if (cache[jumpSpeed][maxSpeed]) {
      if (cache[jumpSpeed][maxSpeed][gravity]) {
        return cache[jumpSpeed][maxSpeed][gravity];
      }
    }
  }

  return null;
};

JumpDescriptor.prototype.setCache = function (steerable, equationResult) {
  var jumpSpeed = steerable.jumpSpeed;
  var maxSpeed = steerable.maxSpeed;
  var gravity = steerable.world.gravity;

  var cache = this.cache;

  if (!cache[jumpSpeed]) {
    cache[jumpSpeed] = {};
  }

  if (!cache[jumpSpeed][maxSpeed]) {
    cache[jumpSpeed][maxSpeed] = {};
  }

  if (!cache[jumpSpeed][maxSpeed][gravity]) {
    cache[jumpSpeed][maxSpeed] = {};
  }

  cache[jumpSpeed][maxSpeed][gravity] = equationResult;
};

JumpDescriptor.prototype.solveQuadraticEquation = function (steerable) {

  var equationResult = this.getEquationResult(steerable);
  if (equationResult) {
    return equationResult;
  }

  equationResult = { time: 0, vx: 0, vz: 0, isAchievable: false };
  this.setCache(steerable, equationResult);

  equationResult.isAchievable = false;

  var jumpSpeed = steerable.jumpSpeed;
  var maxSpeed = steerable.maxSpeed;

  var world = steerable.world;
  var gravity = world.gravity;

  var discriminant = 2 * gravity * this.delta.y + jumpSpeed * jumpSpeed;
  var discriminantSqrt = Math.sqrt(discriminant);

  var jumpTimeCandidate = (-jumpSpeed + discriminantSqrt) / gravity;

  var result = this.checkTime(jumpTimeCandidate, maxSpeed);

  equationResult.time = jumpTimeCandidate;
  equationResult.vx = result.vx;
  equationResult.vz = result.vz;
  equationResult.isAchievable = result.isAchievable;

  if (!result.isAchievable) {
    jumpTimeCandidate = (-jumpSpeed - discriminantSqrt) / gravity;
    result = this.checkTime(jumpTimeCandidate, maxSpeed);

    equationResult.time = jumpTimeCandidate;
    equationResult.vx = result.vx;
    equationResult.vz = result.vz;
    equationResult.isAchievable = result.isAchievable;
  }

  if (!equationResult.isAchievable) {
    return false;
  }

  return equationResult;
};

JumpDescriptor.prototype.checkTime = function (time, maxSpeed) {

  this.checkTimeResult.isAchievable = false;

  var vx = this.delta.x / time;
  var vz = this.delta.z / time;

  var sq = vx * vx + vz * vz;

  if (sq <= maxSpeed * maxSpeed) {
    this.checkTimeResult.isAchievable = true;
    this.checkTimeResult.vx = vx;
    this.checkTimeResult.vz = vz;
  }

  return this.checkTimeResult;
};

var SteeringBehavior = function SteeringBehavior() {
  this.result = new SteerResult();
};

SteeringBehavior.prototype.compute = function () {
  this.result.linear.set(0, 0, 0);
  return this.result;
};

var LOGGER_COMPONENT_NAME$1 = "SeekBehavior";
var LOG_NO_TARGET_POSITION = "No target position.";
var LOG_SPEEDING_UP = "Speeding up.";

var SeekBehavior = function SeekBehavior() {
  SteeringBehavior.call(this);
};

SeekBehavior.prototype = Object.create(SteeringBehavior.prototype);

SeekBehavior.prototype.compute = function (steerable) {

  this.result.linear.set(0, 0, 0);

  if (!steerable.hasTargetPosition) {
    logger.log(LOGGER_COMPONENT_NAME$1, LOG_NO_TARGET_POSITION, steerable.id);
    return this.result;
  }

  this.result.linear.copy(steerable.targetPosition).sub(steerable.position).normalize().multiplyScalar(steerable.maxAcceleration);

  logger.log(LOGGER_COMPONENT_NAME$1, LOG_SPEEDING_UP, steerable.id);

  return this.result;
};

Object.defineProperty(SeekBehavior.prototype, 'constructor', { value: SeekBehavior, enumerable: false, writable: true });

var vectorPool$6 = new VectorPool(10);

var LOGGER_COMPONENT_NAME$2 = "ArriveBehavior";
var LOG_ARRIVED = "Arrived.";
var LOG_SLOWING_DOWN = "Slowing down.";
var LOG_SPEEDING_UP$1 = "Speeding up.";
var LOG_NO_TARGET_POSITION$1 = "Steerable has no target position.";

var ArriveBehavior = function ArriveBehavior(options) {
  SteeringBehavior.call(this);

  this.satisfactionRadius = options.satisfactionRadius;
  this.slowDownRadius = options.slowDownRadius;
};

ArriveBehavior.prototype = Object.create(SteeringBehavior.prototype);

ArriveBehavior.prototype.compute = function (steerable) {

  this.result.linear.set(0, 0, 0);

  if (!steerable.hasTargetPosition) {
    logger.log(LOGGER_COMPONENT_NAME$2, LOG_NO_TARGET_POSITION$1, steerable.id);
    return this.result;
  }

  var toTarget = vectorPool$6.get().copy(steerable.targetPosition).sub(steerable.position);
  var distance = toTarget.getLength();

  var targetVelocity = vectorPool$6.get().set(0, 0, 0);

  if (distance <= this.satisfactionRadius) {
    logger.log(LOGGER_COMPONENT_NAME$2, LOG_ARRIVED, steerable.id);
    this.result.linear.copy(steerable.velocity);
    this.result.linear.negate();
    return this.result;
  }

  targetVelocity.copy(toTarget).normalize().multiplyScalar(steerable.maxSpeed);

  if (distance <= this.slowDownRadius) {
    logger.log(LOGGER_COMPONENT_NAME$2, LOG_SLOWING_DOWN, steerable.id);
    targetVelocity.multiplyScalar(distance / this.slowDownRadius);
  } else {
    logger.log(LOGGER_COMPONENT_NAME$2, LOG_SPEEDING_UP$1, steerable.id);
  }

  this.result.linear.copy(targetVelocity).sub(steerable.velocity);

  return this.result;
};

Object.defineProperty(ArriveBehavior.prototype, 'constructor', { value: ArriveBehavior, enumerable: false, writable: true });

var box = new Box(new Vector3D(), new Vector3D());
var vectorPool$7 = new VectorPool(10);

var LOGGER_COMPONENT_NAME$3 = "AvoidBehavior";
var NO_THREATENING_ENTITY_FOUND = "No threatening entity found.";
var THREATENING_ENTITY_FOUND = "Threatening entity found.";

var AvoidBehavior = function AvoidBehavior(options) {
  SteeringBehavior.call(this);

  this.maxSeeAhead = options.maxSeeAhead;
  this.maxAvoidForce = options.maxAvoidForce;
};

AvoidBehavior.prototype = Object.create(SteeringBehavior.prototype);

AvoidBehavior.prototype.findMostThreateningObstacle = function (steerable) {
  var mostThreatening = null;

  var maxSeeAhead = this.maxSeeAhead;

  var position = steerable.position;
  var velocity = vectorPool$7.get().copy(steerable.velocity);
  velocity.normalize().multiplyScalar(maxSeeAhead);
  var vec2 = vectorPool$7.get().copy(velocity).add(position);
  box.setFromTwoVectors(position, vec2, 0.001);
  box.expandByPoint(steerable.box.min);
  box.expandByPoint(steerable.box.max);

  steerable.executeForEachCloseEntity(function (entity) {

    if (entity instanceof Vertex) {
      return;
    }

    if (box.intersectsBox(entity.box)) {
      if (!mostThreatening) {
        mostThreatening = entity;
      } else {
        var distance = vectorPool$7.get().copy(position).sub(entity.position).getLength();
        var curDistance = vectorPool$7.get().copy(position).sub(mostThreatening.position).getLength();
        if (distance <= curDistance) {
          mostThreatening = entity;
        }
      }
    }
  });

  return mostThreatening;
};

AvoidBehavior.prototype.compute = function (steerable) {
  this.result.linear.set(0, 0, 0);

  var mostThreateningObstacle = this.findMostThreateningObstacle(steerable);

  if (!mostThreateningObstacle) {
    logger.log(LOGGER_COMPONENT_NAME$3, NO_THREATENING_ENTITY_FOUND, steerable.id);
    return this.result;
  }

  logger.log(LOGGER_COMPONENT_NAME$3, THREATENING_ENTITY_FOUND, steerable.id);

  this.result.linear.copy(steerable.velocity).normalize().multiplyScalar(steerable.velocity.getLength() / steerable.maxSpeed).add(steerable.position).sub(mostThreateningObstacle.position).normalize().multiplyScalar(this.maxAvoidForce);
  return this.result;
};

Object.defineProperty(AvoidBehavior.prototype, 'constructor', { value: AvoidBehavior, enumerable: false, writable: true });

var vectorPool$8 = new VectorPool(10);

var BlendedSteeringBehavior = function BlendedSteeringBehavior(list) {
  SteeringBehavior.call(this);

  this.definitions = list;
};

BlendedSteeringBehavior.prototype = Object.create(SteeringBehavior.prototype);

BlendedSteeringBehavior.prototype.compute = function (steerable) {

  this.result.linear.set(0, 0, 0);

  for (var i = 0; i < this.definitions.length; i++) {
    var elem = this.definitions[i];
    var behavior = elem.behavior;
    var weight = elem.weight;

    var result = behavior.compute(steerable);
    if (result) {
      this.result.linear.add(vectorPool$8.get().copy(result.linear).multiplyScalar(weight));
    }
  }

  return this.result;
};

Object.defineProperty(BlendedSteeringBehavior.prototype, 'constructor', { value: BlendedSteeringBehavior, enumerable: false, writable: true });

var LOGGER_COMPONENT_NAME$4 = "PursueBehavior";
var LOG_NO_TARGET_ENTITY = "Entity has no target entity.";
var LOG_SEEKING = "Seeking.";

var vectorPool$9 = new VectorPool(10);

var PursueBehavior = function PursueBehavior(options) {
  SeekBehavior.call(this);

  this.maxPredictionTime = options.maxPredictionTime;
};

PursueBehavior.prototype = Object.create(SeekBehavior.prototype);

PursueBehavior.prototype.compute = function (steerable) {

  this.result.linear.set(0, 0, 0);

  if (!steerable.hasTargetEntity) {
    logger.log(LOGGER_COMPONENT_NAME$4, LOG_NO_TARGET_ENTITY, steerable.id);
    return this.result;
  }

  var targetEntity = steerable.targetEntity;

  var targetPosition = targetEntity.position;
  var speed = steerable.velocity.getLength();

  var predictionTime = this.maxPredictionTime;
  if (speed > 0) {
    var distance = vectorPool$9.get().copy(targetPosition).sub(steerable.position).getLength();
    var tmpPredictionTime = distance / speed;
    if (tmpPredictionTime < this.maxPredictionTime) {
      predictionTime = tmpPredictionTime;
    }
  }

  var v = vectorPool$9.get().copy(targetEntity.velocity).multiplyScalar(predictionTime).add(targetPosition);
  steerable.setTargetPosition(v);

  logger.log(LOGGER_COMPONENT_NAME$4, LOG_SEEKING, steerable.id);

  return SeekBehavior.prototype.compute.call(this, steerable);
};

Object.defineProperty(PursueBehavior.prototype, 'constructor', { value: SeekBehavior, enumerable: false, writable: true });

var vectorPool$10 = new VectorPool(10);

var LookWhereYouAreGoingBehavior = function LookWhereYouAreGoingBehavior() {
  SteeringBehavior.call(this);
};

LookWhereYouAreGoingBehavior.prototype = Object.create(SteeringBehavior.prototype);

LookWhereYouAreGoingBehavior.prototype.compute = function (steerable) {
  this.result.linear.set(0, 0, 0);

  var target = vectorPool$10.get().copy(steerable.position).add(steerable.velocity);

  steerable.setLookTarget(target);

  return this.result;
};

Object.defineProperty(LookWhereYouAreGoingBehavior.prototype, 'constructor', { value: LookWhereYouAreGoingBehavior, enumerable: false, writable: true });

var vectorPool$11 = new VectorPool(10);
var quaternion$1 = new Quaternion();

var Wander2DBehavior = function Wander2DBehavior(options) {
  SteeringBehavior.call(this);

  this.normal = options.normal.clone().normalize();
  this.wanderCircleDistance = options.wanderCircleDistance;
  this.wanderCircleRadius = options.wanderCircleRadius;
  this.angleChange = options.angleChange;
  this.angle = 0;
};

Wander2DBehavior.prototype = Object.create(SteeringBehavior.prototype);

Wander2DBehavior.prototype.compute = function (steerable) {
  var circleCenter = this.getCircleCenter(steerable);
  var displacementForce = this.getDisplacementForce();

  this.result.linear.copy(circleCenter).add(displacementForce);

  this.angle += Math.random() * this.angleChange - this.angleChange * 0.5;

  return this.result;
};

Wander2DBehavior.prototype.getCircleCenter = function (steerable) {
  var dist = this.wanderCircleDistance;
  return vectorPool$11.get().copy(steerable.velocity).normalize().multiplyScalar(dist);
};

Wander2DBehavior.prototype.getDisplacementForce = function () {
  var displacementForce = vectorPool$11.get().set(0, 0, 0);
  displacementForce.x = Math.cos(this.angle);
  displacementForce.z = Math.sin(this.angle);
  displacementForce.normalize().multiplyScalar(this.wanderCircleRadius);
  var quatdiff = quaternion$1.setFromVectors(vectorPool$11.get().set(0, 1, 0), this.normal);
  displacementForce.applyQuaternion(quatdiff);
  return displacementForce;
};

Object.defineProperty(Wander2DBehavior.prototype, 'constructor', { value: Wander2DBehavior, enumerable: false, writable: true });

var vectorPool$12 = new VectorPool(10);

var Wander3DBehavior = function Wander3DBehavior(options) {
  Wander2DBehavior.call(this, {
    wanderCircleDistance: options.wanderSphereDistance,
    angleChange: options.angleChange,
    normal: new Vector3D()
  });

  this.angle2 = 0;

  this.wanderSphereRadius = options.wanderSphereRadius;
};

Wander3DBehavior.prototype = Object.create(Wander2DBehavior.prototype);

Wander3DBehavior.prototype.compute = function (steerable) {
  var circleCenter = this.getCircleCenter(steerable);
  var displacementForce = this.getDisplacementForce();

  this.result.linear.copy(circleCenter).add(displacementForce);

  this.angle += Math.random() * this.angleChange - this.angleChange * 0.5;
  this.angle2 += Math.random() * this.angleChange - this.angleChange * 0.5;

  return this.result;
};

Wander3DBehavior.prototype.getDisplacementForce = function () {
  var displacementForce = vectorPool$12.get().set(0, 0, 0);
  displacementForce.x = Math.sin(this.angle) * Math.cos(this.angle2);
  displacementForce.y = Math.sin(this.angle) * Math.sin(this.angle2);
  displacementForce.z = Math.cos(this.angle);

  return displacementForce.normalize().multiplyScalar(this.wanderSphereRadius);
};

Object.defineProperty(Wander3DBehavior.prototype, 'constructor', { value: Wander3DBehavior, enumerable: false, writable: true });

var FleeBehavior = function FleeBehavior() {
  SeekBehavior.call(this);
};

FleeBehavior.prototype = Object.create(SeekBehavior.prototype);

FleeBehavior.prototype.compute = function (steerable) {
  SeekBehavior.prototype.compute.call(this, steerable);
  this.result.linear.negate();
  return this.result;
};

Object.defineProperty(FleeBehavior.prototype, 'constructor', { value: FleeBehavior, enumerable: false, writable: true });

var EvadeBehavior = function EvadeBehavior(options) {
  PursueBehavior.call(this, options);
};

EvadeBehavior.prototype = Object.create(PursueBehavior.prototype);

EvadeBehavior.prototype.compute = function (steerable) {
  PursueBehavior.prototype.compute.call(this, steerable);
  this.result.linear.negate();
  return this.result;
};

Object.defineProperty(EvadeBehavior.prototype, 'constructor', { value: EvadeBehavior, enumerable: false, writable: true });

var vectorPool$13 = new VectorPool(10);

var LOGGER_COMPONENT_NAME$5 = "PathFollowingBehavior";
var LOG_NO_WAYPOINT = "No waypoint.";
var LOG_JUMP_INITIATED$1 = "Jump initiated.";
var LOG_NEXT_WAYPOINT = "Next waypoint.";
var LOG_PATH_COMPLETED = "Path completed.";

var PathFollowingBehavior = function PathFollowingBehavior(options) {
  SeekBehavior.call(this);

  this.path = options.path;
  this.satisfactionRadius = options.satisfactionRadius || 0;

  this.onJumpCompletionCallback = this.onJumpCompleted.bind(this);
};

PathFollowingBehavior.prototype = Object.create(SeekBehavior.prototype);

PathFollowingBehavior.prototype.getNext = function () {
  var path = this.path;
  path.next();
  return path.getCurrentWaypoint();
};

PathFollowingBehavior.prototype.getCurrentWaypoint = function () {
  return this.path.getCurrentWaypoint();
};

PathFollowingBehavior.prototype.compute = function (steerable) {
  this.result.linear.set(0, 0, 0);
  var path = this.path;

  var currentWayPoint = this.getCurrentWaypoint();
  if (!currentWayPoint) {
    logger.log(LOGGER_COMPONENT_NAME$5, LOG_NO_WAYPOINT, steerable.id);
    return this.result;
  }

  var jumpDescriptor = this.isJumpNeeded(steerable);
  if (jumpDescriptor) {
    this.beforeJumpBehavior = steerable.behavior;
    steerable.jumpDescriptor = jumpDescriptor;
    steerable.onJumpReady();
    steerable.setJumpCompletionListener(this.onJumpCompletionCallback);
    logger.log(LOGGER_COMPONENT_NAME$5, LOG_JUMP_INITIATED$1, steerable.id);
    return this.result;
  }

  var distance = vectorPool$13.get().copy(currentWayPoint).sub(steerable.position).getLength();

  if (distance <= this.satisfactionRadius) {
    currentWayPoint = this.getNext();

    logger.log(LOGGER_COMPONENT_NAME$5, LOG_NEXT_WAYPOINT, steerable.id);

    if (!currentWayPoint) {
      logger.log(LOGGER_COMPONENT_NAME$5, LOG_PATH_COMPLETED, steerable.id);
      return this.result;
    }
  }

  steerable.setTargetPosition(currentWayPoint);
  return SeekBehavior.prototype.compute.call(this, steerable);
};

PathFollowingBehavior.prototype.isJumpNeeded = function (steerable) {

  var path = this.path;
  var jumpDescriptors = path.jumpDescriptors;

  for (var i = 0; i < path.jumpDescriptorLength; i++) {
    var jumpDescriptor = jumpDescriptors[i];
    var distToTakeoffPosition = vectorPool$13.get().copy(steerable.position).sub(jumpDescriptor.takeoffPosition).getLength();
    if (distToTakeoffPosition < jumpDescriptor.takeoffPositionSatisfactionRadius) {
      var quadraticEquationResult = jumpDescriptor.solveQuadraticEquation(steerable);
      if (quadraticEquationResult) {
        return jumpDescriptor;
      }
    }
  }

  return false;
};

PathFollowingBehavior.prototype.onJumpCompleted = function (steerable) {
  var jumpDescriptor = steerable.jumpDescriptor;
  var landingPosition = jumpDescriptor.landingPosition;
  var path = this.path;

  var landingPositionIndex = path.getWaypointIndex(landingPosition);

  while (path.index != landingPositionIndex && !path.isFinished) {
    path.next();
  }

  steerable.setBehavior(this.beforeJumpBehavior);
};

Object.defineProperty(PathFollowingBehavior.prototype, 'constructor', { value: PathFollowingBehavior, enumerable: false, writable: true });

var LOGGER_COMPONENT_NAME$6 = "PrioritySteeringBehavior";
var LOG_COMPUTED = "Computed.";
var LOG_NOT_COMPUTED = "Not computed.";

var PrioritySteeringBehavior = function PrioritySteeringBehavior(options) {
  SteeringBehavior.call(this);

  this.threshold = options.threshold;

  this.list = options.list;
};

PrioritySteeringBehavior.prototype = Object.create(SteeringBehavior.prototype);

PrioritySteeringBehavior.prototype.compute = function (steerable) {
  this.result.linear.set(0, 0, 0);

  for (var i = 0; i < this.list.length; i++) {
    var result = this.list[i].compute(steerable);
    if (result.linear.getLength() > this.threshold) {
      this.result.linear.copy(result.linear);
      logger.log(LOGGER_COMPONENT_NAME$6, LOG_COMPUTED, steerable.id);
      return this.result;
    }
  }

  logger.log(LOGGER_COMPONENT_NAME$6, LOG_NOT_COMPUTED, steerable.id);
  return this.result;
};

Object.defineProperty(PrioritySteeringBehavior.prototype, 'constructor', { value: PrioritySteeringBehavior, enumerable: false, writable: true });

var vectorPool$14 = new VectorPool(10);

var LOGGER_COMPONENT_NAME$7 = "HideBehavior";
var LOG_NO_HIDE_TARGET_ENTITY = "No hide target entity set.";
var LOG_TARGET_ENTITY_OUT_OF_THREAT_DISTANCE = "Target entity is out of threat distance.";
var LOG_NO_HIDING_SPOT_FOUND = "No hiding spot found.";
var LOG_HIDING = "Hiding.";

var HideBehavior = function HideBehavior(options) {
  ArriveBehavior.call(this, {
    satisfactionRadius: options.arriveSatisfactionRadius,
    slowDownRadius: options.arriveSlowDownRadius
  });

  this.hideDistance = options.hideDistance;
  this.threatDistance = options.threatDistance;

  this.hidingSpotFound = false;
  this.bestHidingSpot = new Vector3D();
};

HideBehavior.prototype = Object.create(ArriveBehavior.prototype);

HideBehavior.prototype.compute = function (steerable) {
  this.result.linear.set(0, 0, 0);

  if (!steerable.hideTargetEntity) {
    logger.log(LOGGER_COMPONENT_NAME$7, LOG_NO_HIDE_TARGET_ENTITY, steerable.id);
    return this.result;
  }

  if (vectorPool$14.get().copy(steerable.position).sub(steerable.hideTargetEntity.position).getLength() > this.threatDistance) {
    logger.log(LOGGER_COMPONENT_NAME$7, LOG_TARGET_ENTITY_OUT_OF_THREAT_DISTANCE, steerable.id);
    return this.result;
  }

  this.findHidingSpot(steerable);

  if (!this.hidingSpotFound) {
    logger.log(LOGGER_COMPONENT_NAME$7, LOG_NO_HIDING_SPOT_FOUND, steerable.id);
    return this.result;
  }

  logger.log(LOGGER_COMPONENT_NAME$7, LOG_HIDING, steerable.id);

  steerable.setTargetPosition(this.bestHidingSpot);

  return ArriveBehavior.prototype.compute.call(this, steerable);
};

HideBehavior.prototype.findHidingSpot = function (steerable) {

  this.hidingSpotFound = false;

  var closest = null;

  var self = this;

  steerable.executeForEachCloseEntity(function (entity) {
    if (entity instanceof Steerable || entity instanceof Vertex || entity.excludeFromHide) {
      return;
    }

    var hidingPosition = self.getHidingPosition(entity, steerable);

    var dist = vectorPool$14.get().copy(hidingPosition).sub(steerable.position).getLength();

    if (closest == null || dist < closest) {
      closest = dist;
      self.hidingSpotFound = true;
      self.bestHidingSpot.copy(hidingPosition);
    }
  });
};

HideBehavior.prototype.getHidingPosition = function (hideableEntity, steerable) {
  var targetPosition = steerable.hideTargetEntity.position;

  var hideableRadius = hideableEntity.box.getBoundingRadius();

  var distanceAwayFromHideable = hideableRadius + this.hideDistance;

  var hideableEntityPosition = hideableEntity.position;

  return vectorPool$14.get().copy(hideableEntityPosition).sub(targetPosition).normalize().multiplyScalar(distanceAwayFromHideable).add(hideableEntityPosition);
};

Object.defineProperty(HideBehavior.prototype, 'constructor', { value: HideBehavior, enumerable: false, writable: true });

var RandomWaypointBehavior = function RandomWaypointBehavior(options) {
  PathFollowingBehavior.call(this, options);
};

RandomWaypointBehavior.prototype = Object.create(PathFollowingBehavior.prototype);

RandomWaypointBehavior.prototype.getNext = function () {
  var path = this.path;
  this.currentWayPoint = path.getRandomWaypoint();
  return this.currentWayPoint;
};

RandomWaypointBehavior.prototype.getCurrentWaypoint = function () {
  if (!this.currentWayPoint) {
    return this.getNext();
  }

  return this.currentWayPoint;
};

Object.defineProperty(RandomWaypointBehavior.prototype, 'constructor', { value: RandomWaypointBehavior, enumerable: false, writable: true });

var vectorPool$15 = new VectorPool(10);

var SeparationBehavior = function SeparationBehavior(options) {
  SteeringBehavior.call(this);

  this.strength = options.strength;
};

SeparationBehavior.prototype = Object.create(SteeringBehavior.prototype);

SeparationBehavior.prototype.compute = function (steerable) {
  var linear = this.result.linear;

  linear.set(0, 0, 0);

  var strength = this.strength;
  steerable.executeForEachCloseEntity(function (entity) {
    if (!(entity instanceof Steerable)) {
      return;
    }

    var vec = vectorPool$15.get().copy(steerable.position).sub(entity.position);

    var len = vec.getLength();

    if (len == 0) {
      return;
    }

    vec.normalize().multiplyScalar(strength / len);
    linear.add(vec);
  });

  return this.result;
};

Object.defineProperty(SeparationBehavior.prototype, 'constructor', { value: SeparationBehavior, enumerable: false, writable: true });

var LOGGER_COMPONENT_NAME$8 = "AlignBehavior";
var LOG_CLOSE_ENTITIES_EXIST = "Close entities exist.";
var LOG_NO_CLOSE_ENTITIES_EXIST = "No close entities exist.";

var AlignBehavior = function AlignBehavior() {
  SteeringBehavior.call(this);
};

AlignBehavior.prototype = Object.create(SteeringBehavior.prototype);

AlignBehavior.prototype.compute = function (steerable) {
  var linear = this.result.linear;

  linear.set(0, 0, 0);

  var count = 0;

  steerable.executeForEachCloseEntity(function (entity) {
    if (!(entity instanceof Steerable)) {
      return;
    }

    linear.add(entity.velocity);

    count++;
  });

  if (count > 0) {
    linear.multiplyScalar(1 / count);
    linear.sub(steerable.velocity);
    logger.log(LOGGER_COMPONENT_NAME$8, LOG_CLOSE_ENTITIES_EXIST, steerable.id);
  } else {
    logger.log(LOGGER_COMPONENT_NAME$8, LOG_NO_CLOSE_ENTITIES_EXIST, steerable.id);
  }

  return this.result;
};

Object.defineProperty(AlignBehavior.prototype, 'constructor', { value: AlignBehavior, enumerable: false, writable: true });

var LOGGER_COMPONENT_NAME$9 = "CohesionBehavior";
var LOG_CLOSE_ENTITIES_EXIST$1 = "Close entities exist.";
var LOG_NO_CLOSE_ENTITIES_EXIST$1 = "No close entities exist.";

var CohesionBehavior = function CohesionBehavior() {
  SeekBehavior.call(this);
};

CohesionBehavior.prototype = Object.create(SeekBehavior.prototype);

CohesionBehavior.prototype.compute = function (steerable) {
  var linear = this.result.linear;

  linear.set(0, 0, 0);

  var count = 0;

  steerable.executeForEachCloseEntity(function (entity) {
    if (!(entity instanceof Steerable)) {
      return;
    }

    linear.add(entity.position);

    count++;
  });

  if (count > 0) {
    logger.log(LOGGER_COMPONENT_NAME$9, LOG_CLOSE_ENTITIES_EXIST$1, steerable.id);
    linear.multiplyScalar(1 / count);
    steerable.setTargetPosition(linear);
    return SeekBehavior.prototype.compute.call(this, steerable);
  }

  logger.log(LOGGER_COMPONENT_NAME$9, LOG_NO_CLOSE_ENTITIES_EXIST$1, steerable.id);

  return this.result;
};

Object.defineProperty(CohesionBehavior.prototype, 'constructor', { value: CohesionBehavior, enumerable: false, writable: true });

var vectorPool$16 = new VectorPool(10);

var LOGGER_COMPONENT_NAME$10 = "JumpBehavior";
var LOG_JUMP_NOT_READY = "Jump not ready.";
var LOG_JUMP_ALREADY_TOOK_OFF = "Jump already took off.";
var LOG_EQUATION_RESULT_TIME_ZERO = "Equation result time is zero.";
var LOG_TAKING_OFF = "Taking off.";
var LOG_MATCHING_VELOCITY = "Matching velocity.";

var JumpBehavior = function JumpBehavior() {
  SteeringBehavior.call(this);
};

JumpBehavior.prototype = Object.create(SteeringBehavior.prototype);

JumpBehavior.prototype.compute = function (steerable) {
  var linear = this.result.linear;

  linear.set(0, 0, 0);

  if (!steerable.isJumpReady) {
    logger.log(LOGGER_COMPONENT_NAME$10, LOG_JUMP_NOT_READY, steerable.id);
    return this.result;
  }

  if (steerable.isJumpTakenOff) {
    logger.log(LOGGER_COMPONENT_NAME$10, LOG_JUMP_ALREADY_TOOK_OFF, steerable.id);
    return this.result;
  }

  var jumpDescriptor = steerable.jumpDescriptor;
  var equationResult = jumpDescriptor.getEquationResult(steerable);

  if (equationResult.time == 0) {
    logger.log(LOGGER_COMPONENT_NAME$10, LOG_EQUATION_RESULT_TIME_ZERO, steerable.id);
    return this.result;
  }

  var targetVelocity = vectorPool$16.get().set(equationResult.vx, 0, equationResult.vz);
  if (steerable.velocity.eql(targetVelocity)) {
    steerable.onJumpTakeOff();
    logger.log(LOGGER_COMPONENT_NAME$10, LOG_TAKING_OFF, steerable.id);
    return this.result;
  }

  logger.log(LOGGER_COMPONENT_NAME$10, LOG_MATCHING_VELOCITY, steerable.id);

  steerable.velocity.copy(targetVelocity);
  return this.result;
};

Object.defineProperty(JumpBehavior.prototype, 'constructor', { value: JumpBehavior, enumerable: false, writable: true });

var LOGGER_COMPONENT_NAME$11 = "RandomPathBehavior";
var LOG_PATH_CONSTRUCTED = "Path constructed.";
var LOG_FOLLOWING_PATH = "Following path.";
var LOG_CLOSEST_POINT_NOT_FOUND = "Closest point not found.";

var RandomPathBehavior = function RandomPathBehavior(options) {

  var graph = options.graph;
  var aStar = new AStar(graph);

  var allVertices = [];
  graph.forEachVertex(function (x, y, z) {
    allVertices.push(new Vector3D(x, y, z));
  });

  PathFollowingBehavior.call(this, {
    path: aStar.path,
    satisfactionRadius: options.satisfactionRadius
  });

  this.aStar = aStar;
  this.allVertices = allVertices;
  this.isPathConstructed = false;

  aStar.path.addFinishCallback(function () {
    this.isPathConstructed = false;
  }.bind(this));
};

RandomPathBehavior.prototype = Object.create(PathFollowingBehavior.prototype);

RandomPathBehavior.prototype.getRandomWaypoint = function () {
  var allVertices = this.allVertices;
  return allVertices[Math.floor(Math.random() * allVertices.length)] || null;
};

RandomPathBehavior.prototype.constructPath = function (steerable) {

  var iterate = true;
  var aStar = this.aStar;
  var graph = aStar.graph;

  while (iterate) {
    var startPoint = graph.findClosestVertexToPoint(steerable.position);
    if (!startPoint) {
      startPoint = this.getRandomWaypoint();
      logger.log(LOGGER_COMPONENT_NAME$11, LOG_CLOSEST_POINT_NOT_FOUND, steerable.id);
    }
    var endPoint = this.getRandomWaypoint();

    var path = aStar.findShortestPath(startPoint, endPoint);

    iterate = !path;
  }

  this.isPathConstructed = true;
};

RandomPathBehavior.prototype.compute = function (steerable) {
  if (!this.isPathConstructed) {
    logger.log(LOGGER_COMPONENT_NAME$11, LOG_PATH_CONSTRUCTED, steerable.id);
    this.constructPath(steerable);
  }

  logger.log(LOGGER_COMPONENT_NAME$11, LOG_FOLLOWING_PATH, steerable.id);

  return PathFollowingBehavior.prototype.compute.call(this, steerable);
};

Object.defineProperty(RandomPathBehavior.prototype, 'constructor', { value: RandomPathBehavior, enumerable: false, writable: true });

var box$1 = new Box(new Vector3D(), new Vector3D());
var vect = new Vector3D();

var DebugHelper = function DebugHelper(world, threeInstance, scene) {
  this.world = world;
  this.threeInstance = threeInstance;
  this.scene = scene;

  this.isActive = false;

  this.limeMaterial = new threeInstance.MeshBasicMaterial({ color: "lime", wireframe: true });
  this.magentaMaterial = new threeInstance.MeshBasicMaterial({ color: "magenta", wireframe: true });
  this.redMaterial = new threeInstance.MeshBasicMaterial({ color: "red", wireframe: false });
  this.orangeMaterial = new threeInstance.MeshBasicMaterial({ color: "orange", wireframe: false });
  this.lineMaterial = new threeInstance.LineBasicMaterial({ color: "cyan" });

  this.worldMesh = null;
  this.meshesByEntityID = {};
  this.velocityMeshesByEntityID = {};
  this.lookMeshesByEntityID = {};
  this.meshesByAStarIDs = {};
  this.meshesByJumpDescriptorIDs = {};
  this.visualisedAStars = {};
  this.pathMeshes = [];
  this.edgeMeshes = [];

  this.LOOK_DISTANCE = 100;

  this.world.onEntityInserted = function (entity) {
    if (!this.isActive) {
      return;
    }
    this.addEntity(entity);
  }.bind(this);

  this.world.onEntityRemoved = function (entity) {
    if (!this.isActive) {
      return;
    }
    var mesh = this.meshesByEntityID[entity.id];
    this.scene.remove(mesh);
    delete this.meshesByEntityID[entity.id];

    if (entity instanceof Steerable) {
      var velocityMesh = this.velocityMeshesByEntityID[entity.id];
      this.scene.remove(velocityMesh);
      delete this.velocityMeshesByEntityID[entity.id];

      var lookMesh = this.lookMeshesByEntityID[entity.id];
      this.scene.remove(lookMesh);
      delete this.lookMeshesByEntityID[entity.id];
    }
  }.bind(this);

  this.world.onEntityUpdated = function (entity) {
    if (!this.isActive) {
      return;
    }
    var mesh = this.meshesByEntityID[entity.id];
    mesh.position.set(entity.position.x, entity.position.y, entity.position.z);

    var params = mesh.geometry.parameters;
    mesh.scale.set(entity.size.x / params.width, entity.size.y / params.height, entity.size.z / params.depth);

    if (entity instanceof Steerable) {
      var velocityMesh = this.velocityMeshesByEntityID[entity.id];
      vect.copy(entity.position).add(entity.velocity);
      box$1.setFromTwoVectors(entity.position, vect, 5);
      vect.x = (vect.x + entity.position.x) / 2;
      vect.y = (vect.y + entity.position.y) / 2;
      vect.z = (vect.z + entity.position.z) / 2;
      velocityMesh.position.set(vect.x, vect.y, vect.z);
      velocityMesh.scale.set(box$1.max.x - box$1.min.x, box$1.max.y - box$1.min.y, box$1.max.z - box$1.min.z);

      var lookMesh = this.lookMeshesByEntityID[entity.id];
      vect.copy(entity.lookDirection).normalize().multiplyScalar(this.LOOK_DISTANCE).add(entity.position);
      lookMesh.position.set(vect.x, vect.y, vect.z);
    }
  }.bind(this);

  this.world.onEntityHidden = function (entity) {
    if (!this.isActive) {
      return;
    }
    var mesh = this.meshesByEntityID[entity.id];

    mesh.visible = false;
  }.bind(this);

  this.world.onEntityShown = function (entity) {
    if (!this.isActive) {
      return;
    }
    var mesh = this.meshesByEntityID[entity.id];

    mesh.visible = true;
  }.bind(this);

  this.world.onEntityLookDirectionUpdated = function (entity) {
    if (!this.isActive) {
      return;
    }
    if (entity instanceof Steerable) {
      var lookMesh = this.lookMeshesByEntityID[entity.id];
      vect.copy(entity.lookDirection).normalize().multiplyScalar(this.LOOK_DISTANCE).add(entity.position);
      lookMesh.position.set(vect.x, vect.y, vect.z);
    }
  }.bind(this);
};

DebugHelper.prototype.visualiseJumpDescriptor = function (jumpDescriptor) {
  var id = jumpDescriptor._internalID;

  if (this.meshesByJumpDescriptorIDs[id]) {
    return;
  }

  var p0 = jumpDescriptor.takeoffPosition.clone();
  var p3 = jumpDescriptor.landingPosition.clone();

  var p1 = new Vector3D(p0.x, p0.y + 100, p0.z);
  var p2 = new Vector3D(p3.x, p3.y + 100, p3.z);

  var curve = new this.threeInstance.CubicBezierCurve3(p0, p1, p2, p3);
  var points = curve.getPoints(100);
  var geometry = new this.threeInstance.BufferGeometry().setFromPoints(points);
  var jdMesh = new this.threeInstance.Line(geometry, this.lineMaterial);

  this.meshesByJumpDescriptorIDs[id] = jdMesh;

  this.scene.add(jdMesh);
};

DebugHelper.prototype.visualisePath = function (path, overrideSize) {
  var boxSize = overrideSize || 5;

  var meshes = [];

  for (var i = 0; i < path.length; i++) {
    var wp = path.waypoints[i];
    var waypointMesh = new this.threeInstance.Mesh(new this.threeInstance.BoxBufferGeometry(boxSize, boxSize, boxSize), this.orangeMaterial);
    waypointMesh.position.set(wp.x, wp.y, wp.z);
    this.scene.add(waypointMesh);
    this.pathMeshes.push(waypointMesh);
    meshes.push(waypointMesh);
  }

  return meshes;
};

DebugHelper.prototype.visualiseAStar = function (aStar) {
  var id = aStar._internalID;
  var aStarPathVisualSize = 15;

  if (this.meshesByAStarIDs[id]) {
    return;
  }

  this.visualisedAStars[id] = true;

  if (aStar.searchID > 0) {
    this.meshesByAStarIDs[id] = this.visualisePath(aStar.path, aStarPathVisualSize);
  }

  aStar.onPathConstructed = function () {

    if (!this.visualisedAStars[id]) {
      return;
    }

    var meshes = this.meshesByAStarIDs[id] || [];

    for (var i = 0; i < meshes.length; i++) {
      var mesh = meshes[i];
      this.scene.remove(mesh);
      this.pathMeshes.splice(this.pathMeshes.indexOf(mesh), 1);
    }

    this.meshesByAStarIDs[id] = this.visualisePath(aStar.path, aStarPathVisualSize);
  }.bind(this);
};

DebugHelper.prototype.visualiseGraph = function (graph) {
  var threeInstance = this.threeInstance;
  var lineMaterial = this.lineMaterial;
  var scene = this.scene;
  var edgeMeshes = this.edgeMeshes;

  graph.forEachEdge(function (edge) {
    var geom = new threeInstance.Geometry();
    geom.vertices.push(edge.fromVertex);
    geom.vertices.push(edge.toVertex);
    var line = new threeInstance.Line(geom, lineMaterial);
    scene.add(line);
    edgeMeshes.push(line);
  });
};

DebugHelper.prototype.addEntity = function (entity) {
  var mesh = this.createMeshFromEntity(entity);
  this.meshesByEntityID[entity.id] = mesh;
  this.scene.add(mesh);

  if (entity.isHidden) {
    mesh.visible = false;
  }

  if (entity instanceof Steerable) {
    var velocityMesh = new this.threeInstance.Mesh(new this.threeInstance.BoxBufferGeometry(1, 1, 1), this.magentaMaterial);
    velocityMesh.position.set(entity.position.x, entity.position.y, entity.position.z);
    this.scene.add(velocityMesh);
    this.velocityMeshesByEntityID[entity.id] = velocityMesh;

    var lookMesh = new this.threeInstance.Mesh(new this.threeInstance.BoxBufferGeometry(5, 5, 5), this.redMaterial);
    var lookPosition = new Vector3D().copy(entity.lookDirection).normalize().add(entity.position).multiplyScalar(this.LOOK_DISTANCE);
    lookMesh.position.set(lookPosition.x, lookPosition.y, lookPosition.z);
    this.scene.add(lookMesh);
    this.lookMeshesByEntityID[entity.id] = lookMesh;
  }
};

DebugHelper.prototype.activate = function () {
  this.isActive = true;

  var worldGeometry = new this.threeInstance.BoxBufferGeometry(this.world.width, this.world.height, this.world.depth);
  this.worldMesh = new this.threeInstance.Mesh(worldGeometry, this.limeMaterial);
  this.scene.add(this.worldMesh);

  this.world.forEachEntity(function (entity) {
    this.addEntity(entity);
  }.bind(this));
};

DebugHelper.prototype.deactivate = function () {
  this.isActive = false;

  this.scene.remove(this.worldMesh);
  this.worldMesh = null;

  for (var entityID in this.meshesByEntityID) {
    this.scene.remove(this.meshesByEntityID[entityID]);
  }

  for (var entityID in this.velocityMeshesByEntityID) {
    this.scene.remove(this.velocityMeshesByEntityID[entityID]);
  }

  for (var entityID in this.lookMeshesByEntityID) {
    this.scene.remove(this.lookMeshesByEntityID[entityID]);
  }

  for (var jdID in this.meshesByJumpDescriptorIDs) {
    this.scene.remove(this.meshesByJumpDescriptorIDs[jdID]);
  }

  for (var i = 0; i < this.pathMeshes.length; i++) {
    this.scene.remove(this.pathMeshes[i]);
  }

  for (var i = 0; i < this.edgeMeshes.length; i++) {
    this.scene.remove(this.edgeMeshes[i]);
  }

  this.meshesByEntityID = {};
  this.velocityMeshesByEntityID = {};
  this.lookMeshesByEntityID = {};
  this.meshesByAStarIDs = {};
  this.meshesByJumpDescriptorIDs = {};
  this.visualisedAStars = {};
  this.pathMeshes = [];
  this.edgeMeshes = [];
};

DebugHelper.prototype.createMeshFromEntity = function (entity) {
  var boxGeometry = new this.threeInstance.BoxBufferGeometry(entity.size.x, entity.size.y, entity.size.z);
  var mesh = new this.threeInstance.Mesh(boxGeometry, this.limeMaterial);
  mesh.position.set(entity.position.x, entity.position.y, entity.position.z);

  return mesh;
};

exports.MathUtils = MathUtils;
exports.Vector3D = Vector3D;
exports.VectorPool = VectorPool;
exports.Box = Box;
exports.World = World;
exports.Entity = Entity;
exports.Quaternion = Quaternion;
exports.Path = Path;
exports.Edge = Edge;
exports.Graph = Graph;
exports.MinHeap = MinHeap;
exports.AStar = AStar;
exports.Vertex = Vertex;
exports.Steerable = Steerable;
exports.SteerResult = SteerResult;
exports.JumpDescriptor = JumpDescriptor;
exports.SteeringBehavior = SteeringBehavior;
exports.SeekBehavior = SeekBehavior;
exports.ArriveBehavior = ArriveBehavior;
exports.AvoidBehavior = AvoidBehavior;
exports.BlendedSteeringBehavior = BlendedSteeringBehavior;
exports.PursueBehavior = PursueBehavior;
exports.LookWhereYouAreGoingBehavior = LookWhereYouAreGoingBehavior;
exports.Wander2DBehavior = Wander2DBehavior;
exports.Wander3DBehavior = Wander3DBehavior;
exports.FleeBehavior = FleeBehavior;
exports.EvadeBehavior = EvadeBehavior;
exports.PathFollowingBehavior = PathFollowingBehavior;
exports.PrioritySteeringBehavior = PrioritySteeringBehavior;
exports.HideBehavior = HideBehavior;
exports.RandomWaypointBehavior = RandomWaypointBehavior;
exports.SeparationBehavior = SeparationBehavior;
exports.AlignBehavior = AlignBehavior;
exports.CohesionBehavior = CohesionBehavior;
exports.JumpBehavior = JumpBehavior;
exports.RandomPathBehavior = RandomPathBehavior;
exports.DebugHelper = DebugHelper;
exports.logger = logger;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=Kompute.mjs.map
